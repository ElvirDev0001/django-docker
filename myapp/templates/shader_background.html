<!DOCTYPE html>
<html>
<head>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Ensure it's behind other content */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        function initializeWebGL() {
        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("webgl2");

        if (!gl) {
            alert("Your browser does not support WebGL2");
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resizeCanvas, false);
        resizeCanvas();

        var vsSource = `#version 300 es
        in vec2 vertPosition;
        void main() {
            gl_Position = vec4(vertPosition, 0.0, 1.0);
        }`;

        var fsSource = `#version 300 es
        precision highp float;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform float iTimeDelta;
        uniform int iFrame;
        uniform vec4 iMouse;
        uniform vec4 iDate;
        out vec4 fragColor;

        mat4 RotationMatrixX(float angle){
            return mat4(1., 0., 0., 0.,
                        0., cos(angle), -sin(angle), 0.,
                        0., sin(angle), cos(angle), 0.,
                        0., 0., 0., 1.);
        }

        mat4 RotationMatrixY(float angle){
            return mat4(cos(angle), 0., sin(angle), 0.,
                        0., 1., 0., 0.,
                        -sin(angle), 0., cos(angle), 0.,
                        0., 0., 0., 1.);
        }

        float sdCircle(vec2 st, vec2 pos, float radius){
           return length(st - pos) + radius;
        }

        float sinTheta(float theta){
            return sin(theta * 3.14 / 180.0);
        }

        float cosTheta(float theta){
            return cos(theta * 3.14 / 180.0);
        }

        vec3 getRotation(int index){
            vec3 angle[7];
            angle[0] = vec3( 1.0, 0.5, 0.0 );
            angle[1] = vec3( -1.0, 0.5, 0.0 );
            angle[2] = vec3( 0.0, 2.0, 0.0 );
            return angle [index];
        }

        float getNeonCircle(float circle, float radius, float brightness){
            circle -= radius;
            circle = abs(circle);
            return circle = brightness / circle;
        }

        float random (vec2 st) {
            return fract(sin(dot(st.xy,
                                 vec2(12.9898,79.321)))*
                51758.54);
        }

        float noise (vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);

            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }

        float fbm (vec2 st) {
            int octaves = 2;
            float v = 0.0;
            float a = 0.5;
            vec2 shift = vec2(100.0);
            mat2 rot = mat2(cos(0.5), sin(0.5),
                            -sin(0.5), cos(0.5));
            for (int i = 0; i < octaves; i++) {
                v += a * noise(st);
                st = rot * st * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }

        void main()
        {
            vec2 st = (gl_FragCoord.xy * 2. - iResolution.xy) / iResolution.y;
            vec3 finalColor = vec3(0.);

            vec2 q = vec2(0.);
            q.x = fbm( st + 0.00*iTime);
            q.y = fbm( st + vec2(1.0));
            vec2 r = vec2(0.);
            r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );
            r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);
            float f = fbm(st+r);

            float signed = 1.0;
            for (float i = 0.; i < 3.; i++){
                vec3 col = vec3(0.);
                vec4 st0 = vec4(st, 0.0, 1.0);
                vec3 angle = getRotation(int(i));
                st0 *= RotationMatrixX(angle.x);
                st0 *= RotationMatrixY(angle.y);

                float radius = 0.5;
                float circle = sdCircle(st0.xy, vec2(0.), radius);
                circle = getNeonCircle(circle, 1., 0.005);

                col +=circle;
                float timeCoef = iTime * 2. + i - signed;
                float theta = 90.0 * timeCoef * signed;
                float theta2 = 90.0 * (timeCoef + 1.2) * signed;
                float cosAngle = st0.x * cosTheta(theta);
                float sinAngle = st0.y * sinTheta(theta);

                vec2 point = vec2(cosTheta(theta2), sinTheta(theta2));
                float miniCircle = sdCircle(st0.xy, point * radius, radius);
                miniCircle = getNeonCircle(miniCircle, 0.5, 0.025);

                col *= (cosAngle + sinAngle + miniCircle);
                finalColor = max(finalColor + col, finalColor);
                signed *= -1.;
            }


            float bigCircle = sdCircle(st, vec2(0.), 0.5 * f);
            bigCircle -= 0.2;
            bigCircle = abs(bigCircle);
            bigCircle = 0.05 / bigCircle;
            finalColor = max(finalColor + bigCircle, finalColor);
            finalColor *= vec3(2.0, 1.0, 0.5);

            fragColor = vec4(finalColor,1.0);
        }`;

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);

        // Check for vertex shader compilation errors
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
            return;
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);

        // Check for fragment shader compilation errors
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
            return;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        var iResolutionLocation = gl.getUniformLocation(program, "iResolution");
        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);

        // Check for program linking errors
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR linking program!', gl.getProgramInfoLog(program));
            return;
        }

        var iResolutionLocation = gl.getUniformLocation(program, "iResolution");
        var iTimeLocation = gl.getUniformLocation(program, "iTime");
        var iTimeDeltaLocation = gl.getUniformLocation(program, "iTimeDelta");
        var iFrameLocation = gl.getUniformLocation(program, "iFrame");
        var iMouseLocation = gl.getUniformLocation(program, "iMouse");
        var iDateLocation = gl.getUniformLocation(program, "iDate");

        var lastFrameTime = 0;
        var frame = 0;
        function render(time) {
            time *= 0.001; // Convert time to seconds
            var timeDelta = time - lastFrameTime;
            lastFrameTime = time;

            frame++;
            gl.uniform1f(iTimeLocation, time);
            gl.uniform1f(iTimeDeltaLocation, timeDelta);
            gl.uniform1i(iFrameLocation, frame);

            var date = new Date();
            gl.uniform4f(iDateLocation, date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds());

            gl.clearColor(0.5, 0.5, 0.5, 1.0); // Set clear color to grey
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        document.addEventListener('mousemove', function(event) {
            var mouseX = event.clientX;
            var mouseY = canvas.height - event.clientY;
            gl.uniform4f(iMouseLocation, mouseX, mouseY, 0, 0);
        });

        var vertices = new Float32Array([
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
             1.0,  1.0,
        ]);

        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        var positionAttribLocation = gl.getAttribLocation(program, "vertPosition");
        gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttribLocation);

        requestAnimationFrame(render);
        }
        initializeWebGL(); // Call the function to initialize WebGL
    </script>
</body>
</html>
